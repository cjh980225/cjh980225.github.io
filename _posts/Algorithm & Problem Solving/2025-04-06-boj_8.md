---
title: "[백준_문제_풀이] 1699" 
categories: Algorithm&Problem_Solving
tag: [python, baekjoon, Coding_test]
---

## 문제 링크

[링크](https://www.acmicpc.net/problem/1699)

## 사용 알고리즘 

◾ 수학   
◾ 다이나믹 프로그래밍

# 풀이 
```python
N = int(input())

D = [0] * (N + 1)

for i in range(1, N + 1) : 
    if (i ** 0.5).is_integer() : 
        D[i] = 1
        continue 

    D[i] = 1e9
    j = 1 
    while j * j <= i / 2 : 
        D[i] = min(D[i], 1 + D[i - j * j])
        j += 1
    
print(D[N])
```

## 풀이과정

    ◾ DP는 점화식을 세우는 과정이 중요합니다. 주어진 조건을 보겠습니다. 
        ▪ Dᵢ = i를 제곱수의 합으로 표현할 때, 최소의 갯수입니다. 
            ▫ Dᵢ = 1² + Dᵢ₋₁ = 1 + Dᵢ₋₄ = ••• = 1 + Dᵢ₋ₐ² 입니다. 
            ▫ 따라서 Dᵢ = 1 + min{Dᵢ₋₁, Dᵢ₋₄, •••, Dᵢ₋ₐ²} 입니다. 
            ▫ 1을 더해주는 이유는 갯수를 count하는 것이기 때문에 제곱수를 빼줄 수 있으면 count += 1 하고, 이후 점화식을 진행해 줍니다. 
    ◾ 따라서 list index는 0부터 시작하기 때문에 D를 N + 1개의 0이 가득한 list를 생성합니다. 
    ◾ 다음으로 만약 i가 제곱수라면 D[i] = 1을 넣고, 다른 수에는 아주 큰 수를 입력합니다. 
    ◾ 그리고, while문은 j*j <= i 로 해도 되지만, 최적화를 위해 i / 2로 합니다. 
    ◾ 그리고 제곱수를 한개를 쓰는 것은 위에서 커버를 했습니다. 
    ◾ 따라서, 제곱수를 두개 이상 쓰는 것이기 때문에 제곱수를 생각한다면 i / 2보다 작은 제곱수가 분명 존재하기 때문에 i / 2 까지만 탐색을 합니다. 
    ◾ 이후, D[N]번째 를 출력하며 완료합니다. 